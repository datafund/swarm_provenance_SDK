{"version":3,"sources":["../src/errors.ts","../src/utils.ts","../src/metadata.ts","../src/notary.ts","../src/client.ts"],"names":["sha256","bytesToHex"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Base error class for all SDK errors\n */\nexport class ProvenanceError extends Error {\n  constructor(\n    message: string,\n    public readonly code?: string\n  ) {\n    super(message);\n    this.name = 'ProvenanceError';\n    Object.setPrototypeOf(this, ProvenanceError.prototype);\n  }\n}\n\n/**\n * Error connecting to or communicating with the gateway\n */\nexport class GatewayConnectionError extends ProvenanceError {\n  constructor(\n    message: string,\n    public readonly statusCode?: number,\n    code?: string\n  ) {\n    super(message, code);\n    this.name = 'GatewayConnectionError';\n    Object.setPrototypeOf(this, GatewayConnectionError.prototype);\n  }\n}\n\n/**\n * Error related to postage stamps (acquisition, validation, etc.)\n */\nexport class StampError extends ProvenanceError {\n  constructor(message: string, code?: string) {\n    super(message, code);\n    this.name = 'StampError';\n    Object.setPrototypeOf(this, StampError.prototype);\n  }\n}\n\n/**\n * Error related to notary signing service\n */\nexport class NotaryError extends ProvenanceError {\n  constructor(message: string, code?: string) {\n    super(message, code);\n    this.name = 'NotaryError';\n    Object.setPrototypeOf(this, NotaryError.prototype);\n  }\n}\n\n/**\n * Error when signature verification fails\n */\nexport class VerificationError extends ProvenanceError {\n  constructor(message: string, code?: string) {\n    super(message, code);\n    this.name = 'VerificationError';\n    Object.setPrototypeOf(this, VerificationError.prototype);\n  }\n}\n","import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex } from '@noble/hashes/utils';\n\n/**\n * Convert various input types to Uint8Array\n */\nexport function toBytes(input: Uint8Array | ArrayBuffer | string): Uint8Array {\n  if (input instanceof Uint8Array) {\n    return input;\n  }\n  if (input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  }\n  // String - encode as UTF-8\n  return new TextEncoder().encode(input);\n}\n\n/**\n * Compute SHA256 hash and return as hex string\n */\nexport function sha256Hex(data: Uint8Array | ArrayBuffer | string): string {\n  const bytes = toBytes(data);\n  const hash = sha256(bytes);\n  return bytesToHex(hash);\n}\n\n/**\n * Encode bytes to base64 string\n */\nexport function bytesToBase64(bytes: Uint8Array): string {\n  // Browser and Node.js compatible approach\n  if (typeof Buffer !== 'undefined') {\n    return Buffer.from(bytes).toString('base64');\n  }\n  // Browser fallback\n  let binary = '';\n  for (let i = 0; i < bytes.length; i++) {\n    binary += String.fromCharCode(bytes[i]!);\n  }\n  return btoa(binary);\n}\n\n/**\n * Decode base64 string to bytes\n */\nexport function base64ToBytes(base64: string): Uint8Array {\n  // Browser and Node.js compatible approach\n  if (typeof Buffer !== 'undefined') {\n    return new Uint8Array(Buffer.from(base64, 'base64'));\n  }\n  // Browser fallback\n  const binary = atob(base64);\n  const bytes = new Uint8Array(binary.length);\n  for (let i = 0; i < binary.length; i++) {\n    bytes[i] = binary.charCodeAt(i);\n  }\n  return bytes;\n}\n\n/**\n * Check if a string is valid hex\n */\nexport function isValidHex(str: string): boolean {\n  return /^[0-9a-fA-F]+$/.test(str);\n}\n\n/**\n * Check if a string looks like a valid Swarm reference (64 hex chars)\n */\nexport function isValidSwarmReference(ref: string): boolean {\n  return ref.length === 64 && isValidHex(ref);\n}\n\n/**\n * Normalize a Swarm reference (lowercase, trim)\n */\nexport function normalizeReference(ref: string): string {\n  return ref.trim().toLowerCase();\n}\n","import type { ProvenanceMetadata } from './types.js';\nimport { sha256Hex, bytesToBase64, base64ToBytes, toBytes } from './utils.js';\n\n/**\n * Options for building provenance metadata\n */\nexport interface MetadataBuilderOptions {\n  /** Postage stamp ID */\n  stampId: string;\n  /** Optional provenance standard identifier */\n  standard?: string;\n  /** Optional encryption method */\n  encryption?: string;\n}\n\n/**\n * Build provenance metadata from file content\n */\nexport function buildMetadata(\n  content: Uint8Array | ArrayBuffer | string,\n  options: MetadataBuilderOptions\n): ProvenanceMetadata {\n  const bytes = toBytes(content);\n  const contentHash = sha256Hex(bytes);\n  const base64Data = bytesToBase64(bytes);\n\n  const metadata: ProvenanceMetadata = {\n    data: base64Data,\n    content_hash: contentHash,\n    stamp_id: options.stampId,\n  };\n\n  if (options.standard) {\n    metadata.provenance_standard = options.standard;\n  }\n\n  if (options.encryption) {\n    metadata.encryption = options.encryption;\n  }\n\n  return metadata;\n}\n\n/**\n * Extract the original file content from provenance metadata\n */\nexport function extractContent(metadata: ProvenanceMetadata): Uint8Array {\n  return base64ToBytes(metadata.data);\n}\n\n/**\n * Verify that the content hash in metadata matches the actual content\n */\nexport function verifyContentHash(metadata: ProvenanceMetadata): boolean {\n  const content = extractContent(metadata);\n  const computedHash = sha256Hex(content);\n  return computedHash === metadata.content_hash;\n}\n\n/**\n * Serialize metadata to JSON string for upload\n */\nexport function serializeMetadata(metadata: ProvenanceMetadata): string {\n  return JSON.stringify(metadata);\n}\n\n/**\n * Parse metadata from JSON string\n */\nexport function parseMetadata(json: string): ProvenanceMetadata {\n  const parsed = JSON.parse(json) as unknown;\n\n  if (typeof parsed !== 'object' || parsed === null) {\n    throw new Error('Invalid metadata: expected object');\n  }\n\n  const obj = parsed as Record<string, unknown>;\n\n  if (typeof obj['data'] !== 'string') {\n    throw new Error('Invalid metadata: missing or invalid data field');\n  }\n  if (typeof obj['content_hash'] !== 'string') {\n    throw new Error('Invalid metadata: missing or invalid content_hash field');\n  }\n  if (typeof obj['stamp_id'] !== 'string') {\n    throw new Error('Invalid metadata: missing or invalid stamp_id field');\n  }\n\n  const result: ProvenanceMetadata = {\n    data: obj['data'],\n    content_hash: obj['content_hash'],\n    stamp_id: obj['stamp_id'],\n  };\n  if (typeof obj['provenance_standard'] === 'string') {\n    result.provenance_standard = obj['provenance_standard'];\n  }\n  if (typeof obj['encryption'] === 'string') {\n    result.encryption = obj['encryption'];\n  }\n  return result;\n}\n","import type { NotarySignature, ProvenanceMetadata } from './types.js';\nimport { sha256Hex } from './utils.js';\nimport { VerificationError } from './errors.js';\n\n/**\n * Reconstruct the message that was signed by the notary\n */\nexport function reconstructSignedMessage(\n  signature: NotarySignature,\n  _metadata: ProvenanceMetadata\n): string {\n  // The signed message format is typically:\n  // \"Provenance Notary\\nTimestamp: {timestamp}\\nData Hash: {data_hash}\"\n  // But we should use the actual format specified in the signature\n  const format = signature.signed_message_format;\n\n  // Replace placeholders with actual values\n  let message = format;\n  message = message.replace('{timestamp}', signature.timestamp);\n  message = message.replace('{data_hash}', signature.data_hash);\n\n  return message;\n}\n\n/**\n * Convert a value to canonical JSON (sorted keys, no whitespace)\n */\nfunction toCanonicalJson(value: unknown): string {\n  if (value === null || value === undefined) {\n    return JSON.stringify(value);\n  }\n  if (typeof value !== 'object') {\n    return JSON.stringify(value);\n  }\n  if (Array.isArray(value)) {\n    return '[' + value.map(toCanonicalJson).join(',') + ']';\n  }\n  // Object - sort keys\n  const keys = Object.keys(value as Record<string, unknown>).sort();\n  const pairs = keys.map(\n    (k) => JSON.stringify(k) + ':' + toCanonicalJson((value as Record<string, unknown>)[k])\n  );\n  return '{' + pairs.join(',') + '}';\n}\n\n/**\n * Verify that the data hash in the signature matches the metadata\n */\nexport function verifyDataHash(signature: NotarySignature, metadata: ProvenanceMetadata): boolean {\n  // The data hash is SHA-256 of the canonical JSON of the hashed fields\n  // Per gateway docs: hash of canonical JSON (sorted keys, no whitespace)\n  const hashedFields = signature.hashed_fields;\n\n  // Get the value to hash based on hashed_fields\n  // Typically [\"data\"] means hash the canonical JSON of metadata.data\n  let valueToHash: unknown;\n\n  if (hashedFields.length === 1 && hashedFields[0] === 'data') {\n    // Most common case: hash the data field\n    valueToHash = metadata.data;\n  } else {\n    // Build object from multiple fields\n    const obj: Record<string, unknown> = {};\n    for (const field of hashedFields) {\n      if (field === 'content_hash') {\n        obj[field] = metadata.content_hash;\n      } else if (field === 'data') {\n        obj[field] = metadata.data;\n      } else if (field === 'stamp_id') {\n        obj[field] = metadata.stamp_id;\n      } else if (field === 'provenance_standard') {\n        obj[field] = metadata.provenance_standard ?? '';\n      }\n    }\n    valueToHash = obj;\n  }\n\n  // Compute canonical JSON and hash it\n  const canonicalJson = toCanonicalJson(valueToHash);\n  const computedHash = sha256Hex(canonicalJson);\n  return computedHash === signature.data_hash;\n}\n\n/**\n * Recover the signer address from an EIP-191 signature\n * Note: This is a placeholder - full implementation requires ethers or viem\n */\nexport function recoverSigner(message: string, signature: string): string {\n  // For now, we just return the signature prefix as a placeholder\n  // Real implementation would use ethers.verifyMessage or viem's verifyMessage\n  void message;\n  void signature;\n  throw new VerificationError(\n    'Signature recovery not implemented - install ethers or viem for full verification',\n    'NOT_IMPLEMENTED'\n  );\n}\n\n/**\n * Verify a notary signature\n * Returns true if:\n * 1. The data hash matches the metadata\n * 2. The signature is valid (if verification is possible)\n *\n * @param signature - The notary signature to verify\n * @param metadata - The provenance metadata\n * @param expectedSigner - Optional expected signer address\n * @returns Object with verification status and details\n */\nexport function verifySignature(\n  signature: NotarySignature,\n  metadata: ProvenanceMetadata,\n  expectedSigner?: string\n): { valid: boolean; dataHashValid: boolean; signerValid?: boolean; error?: string } {\n  // Step 1: Verify the data hash\n  const dataHashValid = verifyDataHash(signature, metadata);\n\n  if (!dataHashValid) {\n    return {\n      valid: false,\n      dataHashValid: false,\n      error: 'Data hash mismatch',\n    };\n  }\n\n  // Step 2: Check if signer matches expected (if provided)\n  if (expectedSigner) {\n    const signerValid =\n      signature.signer.toLowerCase() === expectedSigner.toLowerCase();\n    if (!signerValid) {\n      return {\n        valid: false,\n        dataHashValid: true,\n        signerValid: false,\n        error: `Signer mismatch: expected ${expectedSigner}, got ${signature.signer}`,\n      };\n    }\n    return {\n      valid: true,\n      dataHashValid: true,\n      signerValid: true,\n    };\n  }\n\n  // Without crypto verification, we can only verify the data hash\n  // The signature itself would need ethers/viem to verify\n  return {\n    valid: true,\n    dataHashValid: true,\n  };\n}\n\n/**\n * Verify all signatures on a document\n */\nexport function verifyAllSignatures(\n  signatures: NotarySignature[],\n  metadata: ProvenanceMetadata,\n  expectedSigner?: string\n): { allValid: boolean; results: Array<{ index: number; valid: boolean; error?: string }> } {\n  const results: Array<{ index: number; valid: boolean; error?: string }> = signatures.map((sig, index) => {\n    const result = verifySignature(sig, metadata, expectedSigner);\n    const item: { index: number; valid: boolean; error?: string } = {\n      index,\n      valid: result.valid,\n    };\n    if (result.error !== undefined) {\n      item.error = result.error;\n    }\n    return item;\n  });\n\n  return {\n    allValid: results.every((r) => r.valid),\n    results,\n  };\n}\n","import type {\n  ProvenanceClientConfig,\n  UploadOptions,\n  DownloadOptions,\n  UploadResult,\n  DownloadResult,\n  NotaryInfo,\n  PoolStatus,\n  AcquiredStamp,\n  GatewayUploadResponse,\n  GatewayNotaryInfoResponse,\n  GatewayPoolStatusResponse,\n  GatewayAcquireStampResponse,\n  GatewayErrorResponse,\n  ProvenanceMetadata,\n  NotarySignature,\n} from './types.js';\nimport {\n  ProvenanceError,\n  GatewayConnectionError,\n  StampError,\n  NotaryError,\n} from './errors.js';\nimport { buildMetadata, extractContent, verifyContentHash } from './metadata.js';\nimport { verifyAllSignatures } from './notary.js';\nimport { toBytes } from './utils.js';\n\nconst DEFAULT_GATEWAY_URL = 'https://provenance-gateway.dev.datafund.io';\nconst DEFAULT_TIMEOUT = 30000;\n\n/**\n * Main client for interacting with the Swarm Provenance Gateway\n */\nexport class ProvenanceClient {\n  private readonly gatewayUrl: string;\n  private readonly timeout: number;\n\n  constructor(config: ProvenanceClientConfig = {}) {\n    this.gatewayUrl = (config.gatewayUrl ?? DEFAULT_GATEWAY_URL).replace(/\\/$/, '');\n    this.timeout = config.timeout ?? DEFAULT_TIMEOUT;\n  }\n\n  /**\n   * Check if the gateway is healthy and reachable\n   */\n  async health(): Promise<boolean> {\n    try {\n      const response = await this.fetch('/health');\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get notary service information\n   */\n  async notaryInfo(): Promise<NotaryInfo> {\n    const response = await this.fetch('/api/v1/notary/info');\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        return { enabled: false, available: false };\n      }\n      throw await this.handleError(response);\n    }\n\n    const data = (await response.json()) as GatewayNotaryInfoResponse;\n    const info: NotaryInfo = {\n      enabled: data.enabled,\n      available: data.available,\n    };\n    if (data.address !== undefined) {\n      info.address = data.address;\n    }\n    if (data.message !== undefined) {\n      info.message = data.message;\n    }\n    return info;\n  }\n\n  /**\n   * Get stamp pool status\n   */\n  async poolStatus(): Promise<PoolStatus> {\n    const response = await this.fetch('/api/v1/pool/status');\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        return { enabled: false, available: {}, reserve: {} };\n      }\n      throw await this.handleError(response);\n    }\n\n    const data = (await response.json()) as GatewayPoolStatusResponse;\n    return {\n      enabled: data.enabled,\n      available: data.available,\n      reserve: data.reserve,\n    };\n  }\n\n  /**\n   * Acquire a stamp from the pool\n   */\n  async acquireStamp(size: 'small' | 'medium' | 'large' = 'small'): Promise<AcquiredStamp> {\n    const response = await this.fetch('/api/v1/pool/acquire', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ size }),\n    });\n\n    if (!response.ok) {\n      const error = await this.handleError(response);\n      throw new StampError(error.message, error.code);\n    }\n\n    const data = (await response.json()) as GatewayAcquireStampResponse;\n    return {\n      batchId: data.batch_id,\n      depth: data.depth,\n      sizeName: data.size_name,\n      fallbackUsed: data.fallback_used,\n    };\n  }\n\n  /**\n   * Upload provenance data to Swarm\n   */\n  async upload(\n    content: Uint8Array | ArrayBuffer | string | File | Blob,\n    options: UploadOptions = {}\n  ): Promise<UploadResult> {\n    // Get stamp - either from options or acquire from pool\n    let stampId = options.stampId;\n    if (!stampId) {\n      const stamp = await this.acquireStamp(options.poolSize ?? 'small');\n      stampId = stamp.batchId;\n    }\n\n    // Convert content to bytes\n    let bytes: Uint8Array;\n    if (content instanceof Blob) {\n      const buffer = await content.arrayBuffer();\n      bytes = new Uint8Array(buffer);\n    } else {\n      bytes = toBytes(content);\n    }\n\n    // Build metadata\n    const metadataOptions: { stampId: string; standard?: string } = { stampId };\n    if (options.standard !== undefined) {\n      metadataOptions.standard = options.standard;\n    }\n    const metadata = buildMetadata(bytes, metadataOptions);\n\n    // Build query params\n    const params = new URLSearchParams();\n    params.set('stamp_id', stampId);\n    if (options.contentType) {\n      params.set('content_type', options.contentType);\n    }\n    if (options.sign === 'notary') {\n      params.set('sign', 'notary');\n    }\n\n    // Create form data with the metadata JSON as file content\n    const formData = new FormData();\n    const metadataBlob = new Blob([JSON.stringify(metadata)], { type: 'application/json' });\n    formData.append('file', metadataBlob, 'provenance.json');\n\n    const response = await this.fetch(`/api/v1/data/?${params.toString()}`, {\n      method: 'POST',\n      body: formData,\n    });\n\n    if (!response.ok) {\n      const error = await this.handleError(response);\n      if (options.sign === 'notary') {\n        throw new NotaryError(error.message, error.code);\n      }\n      throw error;\n    }\n\n    const data = (await response.json()) as GatewayUploadResponse;\n\n    const result: UploadResult = {\n      reference: data.reference,\n      metadata,\n    };\n\n    if (data.signed_document) {\n      result.signedDocument = {\n        metadata: data.signed_document.metadata,\n        signatures: data.signed_document.signatures,\n      };\n    }\n\n    return result;\n  }\n\n  /**\n   * Download and optionally verify provenance data from Swarm\n   */\n  async download(reference: string, options: DownloadOptions = {}): Promise<DownloadResult> {\n    const response = await this.fetch(`/api/v1/data/${reference}`);\n\n    if (!response.ok) {\n      throw await this.handleError(response);\n    }\n\n    let metadata: ProvenanceMetadata;\n    let signatures: NotarySignature[] | undefined;\n\n    // Parse response - gateway may return:\n    // 1. Wrapped format: {metadata: {...}, signatures: [...]}\n    // 2. Direct format: {data: \"...\", content_hash: \"...\", stamp_id: \"...\", signatures?: [...]}\n    const data = (await response.json()) as\n      | { metadata: ProvenanceMetadata; signatures?: NotarySignature[] }\n      | (ProvenanceMetadata & { signatures?: NotarySignature[] });\n\n    if ('metadata' in data && data.metadata && typeof data.metadata === 'object') {\n      // Wrapped format\n      metadata = data.metadata;\n      signatures = data.signatures;\n    } else {\n      // Direct format - signatures at same level as metadata fields\n      const directData = data as ProvenanceMetadata & { signatures?: NotarySignature[] };\n      if (directData.signatures && Array.isArray(directData.signatures)) {\n        signatures = directData.signatures;\n      }\n      metadata = {\n        data: directData.data,\n        content_hash: directData.content_hash,\n        stamp_id: directData.stamp_id,\n      };\n      if (directData.provenance_standard !== undefined) {\n        metadata.provenance_standard = directData.provenance_standard;\n      }\n      if (directData.encryption !== undefined) {\n        metadata.encryption = directData.encryption;\n      }\n    }\n\n    // Extract file content\n    const file = extractContent(metadata);\n\n    // Verify content hash\n    const contentHashValid = verifyContentHash(metadata);\n    if (!contentHashValid) {\n      throw new ProvenanceError('Content hash verification failed', 'CONTENT_HASH_MISMATCH');\n    }\n\n    const result: DownloadResult = {\n      file,\n      metadata,\n    };\n    if (signatures !== undefined) {\n      result.signatures = signatures;\n    }\n\n    // Verify signatures if present and requested\n    if (signatures && signatures.length > 0) {\n      const shouldVerify = options.verify !== false;\n      if (shouldVerify) {\n        const notary = await this.notaryInfo();\n        const verification = verifyAllSignatures(signatures, metadata, notary.address);\n        result.verified = verification.allValid;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Make a fetch request to the gateway\n   */\n  private async fetch(path: string, init?: RequestInit): Promise<Response> {\n    const url = `${this.gatewayUrl}${path}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    // Merge headers, adding X-Payment-Mode: free for x402 compatibility\n    const headers = new Headers(init?.headers);\n    if (!headers.has('X-Payment-Mode')) {\n      headers.set('X-Payment-Mode', 'free');\n    }\n\n    try {\n      const response = await fetch(url, {\n        ...init,\n        headers,\n        signal: controller.signal,\n      });\n      return response;\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new GatewayConnectionError('Request timed out', undefined, 'TIMEOUT');\n      }\n      throw new GatewayConnectionError(\n        error instanceof Error ? error.message : 'Failed to connect to gateway',\n        undefined,\n        'CONNECTION_FAILED'\n      );\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  /**\n   * Handle error responses from the gateway\n   */\n  private async handleError(response: Response): Promise<GatewayConnectionError> {\n    let message = `Gateway error: ${response.status} ${response.statusText}`;\n    let code: string | undefined;\n\n    try {\n      const data = (await response.json()) as GatewayErrorResponse;\n      message = data.detail || message;\n      code = data.code;\n    } catch {\n      // Ignore JSON parse errors\n    }\n\n    return new GatewayConnectionError(message, response.status, code);\n  }\n}\n"]}